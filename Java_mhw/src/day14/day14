day14
<Review>
클래스 
	사용하는 이유?
	- 정보를 편하게 관리하고 기능을 쉽게 사용하기 위해서.
	
	구성
	-멤버변수(필드)
	-멤버메소드
		*메소드는 객체멤버메소드일 떄와 클래스 멤버메소드 일 때 매개변수가 많이 다를 수 있다. 
			-객체 변수 : 각 객체마다 멤버변수들이 있다
				=>객체멤버변수들은 클래스의 변수들을 바로 사용할 수 있기때문에, 바로 메소드에 사용가능 함.
			-클래스 변수 : 하나의 멤버변수를 모든 객체가 같이 사용
				=>클래스멤버변수들은 객체변수들을 바로 사용할 수 없기때문에, 매개변수들을 넘겨줘야 함.
	-생성자
		- 생성자는 여러개 있어도 한 개만 선택된다.
		- 생성자는 객체를 생성할 때 호출한다. 객체를 통해 호출할 수 없다(객체명.ㅇㅁㄹㅇㄴ  => 안되는 예).
		- 생성자 이름은 클래스명과 동일
		- 생성자가 하나도 없으면 기본 생성자가 자동으로 생성된다.
		- 나를 나타내는 객체 this.
				this(): 생성자
				super : 부모를 나타내는 객체
				super() : 부모클래스 생성자
		- 리턴타입이 없음
				class A{
						public A(){}	//생성자
						public void A(){}	// 메소드
		- 생성자는 부모클래스의 생성자를 호출한다.


상속(부모클래스에 있는 멤버 변수/메소드를 물려 받는 것)
	- 편하게 클래스를 만드려고	
	- 표준으로 제공되는 클래스들을 상속받기 위해서
	- 다형성을 이용하면 매개변수나 멤버변수를 다양하게 적용할 수 있음
	- 다양한 클래스를 하나의 부모 클래스로 관리하기 위해
		=>도형예제 참고
	- 접근제한자에 따라 접근할 수 없을 수도 있다(예: private)
	- 오버라이드 : 부모클래스에게 물려받은 메소드를 재정의하는 것
		*메소드선언이 부모클래스의 메소드와 같은 경우만 가능함.
		(!=오버로드/오버로딩: 동일한 이름의 메소드/생성자가 여러개 있는 경우)
			*매개변수가 다른경우(갯수,타입)
	
	상속 가능 : A는 B이다.  "is a 관계"
		!=포함(멤버변수) : A는 B를 가지고있다.		"has a 관계"