day12

조건문과 반복문에서 실행물이 1줄이면 {}를 생략할 수 있다. => package day12, ForTest

<Review>
자바: 객체지향 프로그래밍 언어(OOP = Oriented Object Programming)

예)전화를 걸어야 한다.
절차지향								vs			객체지향
-전화거는 기능을 만들어서								-전화를 걸 수 있는 기능을 가진 핸드폰을 설계	=>클래스
 전화를 건다.	예)board>BoardTest					설계도를 통해 핸드폰을 만든다 => 객체 생성
 												핸드폰으로 전화를 건다 => 객체의 메소드 호출. 예) board>BoardTest2


클래스 
	- 멤버변수 	: 정보
	- 멤버메소드	: 기능
	- 생성자		: 정보의 초기값 설정

멤버변수
	- 객체는 멤버변수가 될 수 없다(X) 		: 객체는 멤버변수가 될 수 있다. (일반변수도 당연히 됨), Board 파일 참고
	- 멤버변수는 생성자에서 사용가능하다 (O) 	: 
	- 멤버변수는 멤버메소드에서 사용가능하다 (O)	: 멤버변수는 클래스내에서 사용가능하다. 단, 객체변수냐 클래스변수냐에 따라 불가능할 수도 있다. 
	- 일반적으로 접근제한자를 private로 한다(O): 일.반.적.으.로! getter와 setter가 필요하다(이클립스에서 우클릭으로 생성가능)
	
멤버메소드
	- 기능& 매개변수& 리턴타입을 정리한 후, 메소드를 선언(접근제한자 리턴타입 메소드명~~~)하고 구현{중괄호 안}한다.
	- 오버로딩 : 동일한 이름을 가진 메소드가 여러개 있는 경우 => 매개변수가 다를 때(갯수, 타입)

생성자
	- 멤버변수를 초기화하는 곳
	- new 연산자를 통해서 객체를 생성한 후, 호출이 된다.
		=> 객체.생성자() 로 호출할 수 없다. *why? new 연산자가 붙어야 함. => 따라서, 생성자는 마음대로 부를 수 없다.
		+ 객체.생성자() => 왜 board.(메소드명) 해가지고 많이 호출한거 있잖아 그거 말하는 듯
	- 이름이 클래스명과 같다.
	- 오버로딩이 가능함. => 생성자가 여러개 있는 경우나 매개변수가 다를 때
	- this()를 이용하여 다른 생성자를 호출할 수 있다.
	- 클래스에 생성자가 하나도 없을 때, 기본생성자가 자동으로 만들어진다.
	- 클래스에 생성자가 하나라도 있을 때, 기본 생성자가 만들어지지 않는다. (생성자가 있기만하면)
	

클래스 변수/메소드						vs				객체 변수/메소드
- 클래스가 메모리에 올랐을 때, 생성 						- 객체를 생성할 때, 생성
- 객체 생성 없이 호출이 가능 								- 객체를 꼭 생성해야 호출 가능
- static이 붙음										- static이 안붙음
- 클래스 변수는 모든 객체가 공유							- 객체 변수는 각 객체마다 변수가 존재
	=> 객체가 n개라면 클래스 변수는 1개						=> 객체가 n개라면 객체 변수는 n개

	- 클래스 메소드를 객체 메소드에서 호출할 수 있다 	(O)	: 클래스 메소드는 객체를 생성하기 전에 만들어진다. 따라서, 객체를 생성하고 나서 호출되는 객체 메소드에서 클래스 메소드를 호출 가능
	- 클래스 변수를 객체 메소드에서 호출할 수 있다 	(O)	: 위와 같은 이유.
	- 객체 메소드를 클래스 메소드에서 호출할 수 있다 	(X)	: 위와 반대이유 (순서)->클래스 메소드 생성 이후에 객체 생성/메소드생성일텐데 클래스 메소드 생성이후 객체 메소드가 없을 수도 있음. 
	- 객체 변수를 클래스 메소드에서 호출할 수 있다 	(X)	: 
	- 클래스 변수를 클래스 메소드에서 호출할 수 있다 	(O)	: 
	- 객체 변수를 객체 메소드에서 호출할 수 있다 	(O)	: 
	
final : 바꿀 수 없는 
	- 변수 : 상수 처리
	- 메소드 : 오버라이딩 불가능
	- 클래스 : 상속할 수 없음
	
--------혼공자 (307p)까지 진도 나간 것임.

클래스 상속 : 부모 클래스의 멤버변수/메소드를 물려 받는 것
	- 접근제한자가 private이면 물려받지 못함 => 부모클래스에 해당 변수에 대한 getter와 setter를 만들어서 자식 클래스에서 사용해야 함.
	- 접근제한자가 디폴트이면 같은 패키지가 아닌 경우 물려받지 못함
	- 접근제한자가 public, protected이면 물려받음
	
	클래스 상속 생김새(package12, day12, InheritanceTest 참고) :	
			class 자식클래스명 extends 부모클래스명{
	
		}

	클래스 상속을 하는 이유
		- 코드의 중복을 제거할 수 있다
		- 부모클래스에 구현된 메소드를 사용할 수 있기 때문에 효율이 좋다
	
	클래스 상속을 할 수 있는 경우
		- "A는 B이다"가 성립하면 상속을 할 수 있다. => A : 자식클래스, B는 부모클래스
			ex) 사람은 동물이다. => (O) => 동물 클래스를 상속받아 사람 클래스를 만들 수 있다.
		 	ex) 동물은 사람이다. => (X) => 사람 클래스를 상속받아 동물 클래스로 만들 수 없다.
		
			예시1) 스마트폰은 폰이다 => (O) => 스마트폰 : 자식클래스, 폰 : 부모클래스
			예시) 스마트폰은 카메라이다 => (X) => 상속 불가능 
			
			예시2) => 하나의 부모클래스로 여러개의 자식클래스를 만들 수 있다.
			사각형은 도형이다.	=> (O)
			삼각형은 도형이다.	=> (O)		부모 : 도형, 자식: 사각형, 삼각형, 원
			원은 도형이다.		=> (O)			

	상속받은 자식클래스의 생성자
		- 자식클래스의 생성자를 호출하면 부모클래스의 생성자가 먼저 호출이 된 후, 자식 클래스의 생성자가 실행되는데 자식 클래스 생성자 안에 부모 생성자가 있어서 먼저 호출이 된다.
		- 자식클래스의 생성자 안에 부모클래스의 생성자가 없으면, 부모클래스의 기본 생성자가 자동으로 호출 됨
		- 부모클래스의 생성자는 super()를 통해 호출 //내 생성자: this()   부모생성자: super()를 통해 호출 
		- 부모클래스의 생성자를 호출하려면 super()위에 코드가 없어야 한다.	//this()도 똑같음, 앞에 아무것도 나오면 안돼.
		- 부모클래스의 생성자를 super()를 통해 호출하면 본인 클래스의 생성자this()를 이용할 수 없다.
		
		
				super (혼공자 313p)						vs					this
				-부모 클래스의 객체를 의미										-내 클래스의 객체를 의미
				-생성자: super();												-생성자: this();
				-멤버호출: 													-멤버호출:
					super.멤버변수												this.멤버변수
					super.멤버메소드()												this.멤버메소드()
				-접근제한자에 따라 부모 클래스의 메소드를 호출할 수 없을 수 있다.			-접근 제한자 상관없이 호출 가능
				
	