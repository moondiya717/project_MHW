day15

추상클래스
	- 공통된 멤버변수(필드)와 메소드의 이름을 통일하려고 사용
	=> 시간을 절약

	추상클래스 생김새
		abstract class 클래스명{
	
		}
	
	추상클래스 특징
		- 추상 클래스를 이용하여 객체를 생성할 수 없다.
			=> 추상 클래스를 상속한 자식 클래스를 만든 후, 객체를 생성해야 한다.
		- 추상 클래스는 추상 메소드를 생성할 수 있다.
		- 추상 메소드는 선언부만 있고 구현부가 없는 메소드
			=> 기능명은 있지만 구현되지 않음
		- 추상 클래스에 추상 메소드가 있으면 추상 클래스를 상속받은 자식 클래스에서 (자식 클래스가 일반 클래스인 경우) 추상 메소드를 무조건 오버라이딩 해야 한다.
			=> 구현부가 없기 때문에 구현해줘야 한다
		- 추상 메소드가 있으면 일반 클래스가 될 수 없고 추상클래스여야 한다.
	
인터페이스 (기능 명세해서 통일되게(=표준화) 작업할 수 있도록 해줌)
	- 메소드는 추상 메소드만 있을 수 있다
		=> abstract라는 키워드가 없어도 자동으로 추가가 됨.
	- 변수는 있을 수 없고, 클래스 상수만 있을 수 있다
		=> static final이라는 키워드가 없어도 자동으로 추가 됨. 
	- 매개변수의 다형성을 인터페이스를 이용해서도 적용할 수 있다.
		*매개변수의 다형성
			- 메소드의 매개변수를 부모클래스로 설정하면, 해당 부모 클래스를 상속받은 자식 클래스들이 매개변수로 올 수 있다.
	- 인터페이스를 이용하여 객체를 만들 수 없다. (기능구현이 안되어있어서 객체를 만들 수 없음)
	- 인터페이스는 구현 클래스를 생성한 후, 객체를 만들 수 있다.
	- 상속은 extends, 구현은 implements를 이용
	- 구현클래스는 여러개의 인터페이스를 구현할 수 있다. 
	- 구현부가 없어서 기능을 한눈에 볼 수 있음. => 제품설명서의 목차 같은 거래
	
	추상클래스								vs			인터페이스
	 - 객체멤버변수, 객체상수,  							 -클래스 상수, 추상 메소드
	   클래스멤버변수, 클래스 상수,
	   객체메소드, 클래스메소드, 추상메소드					
	
	인터페이스의 상속
	 - 클래스의 상속과는 다르게, 인터페이스의 상속은 다중 상속이 가능(일반 상속과 다르게, 부모에게 물려받은 기능이나 멤버변수의 같은 이름등으로 인한 충돌이랑 상관이 없음)
	 - 


				일반클래스		추상클래스			인터페이스
멤버변수			O			O				X
상수				O			O				O
메소드			O			O				X
추상메소드			X			O				O
객체생성			O			X(자식클래스생성)	X(구현클래스생성)		*추상클래스/인터페이스는 추상메소드가 있어서 객체생성 불가
상속갯수			1개			1개				여러개



타입변환
	- 상속
	 1. 자동 	
		자식클래스 객체1 = new 자식클래스();
		부모클래스 객체2 = 객체1;	
	 2. 강제(조건부로 가능)
	 	부모클래스 객체3 = new 자식클래스();
	 	자식클래스 객체4 = (자식클래스) 객체3; 
	 	
	 -구현
	  1. 자동
	  	구현클래스 객체5 = new 구현클래스();
	  	인터페이스 객체6 = 객체5;
	  2. 강제
	   인터페이스 객체7 = new 인터페이스();	//인터페이스를 통해서 객체를 만들 수 없다. 기능이 구현이 되어있지 않기때문에 => 인터페이스 객체7=new구현클래스();
	   구현클래스 객체8 = (구현클래스)객체7;
	   

중첩클래스
	- A클래스를 구현할 때, B클래스가 필요하지만 다른클래스에서는 B클래스가 쓸모없는 경우, 중첩 클래스를 이용
	
	중첩클래스 생김새: 클래스 안에 클래스가 선언되어 있는 형태 
		class A{
				class B{
				}
		}


익명 객체 (p424)
	-일반적으로 클래스를 생성하고, 생성한 클래스를 이용하여 객체를 만듬.
		=> 객체의 이름이 있다.
	1. 자식 클래스 대신 익명 객체 사용
		=> 자식 클래스가 재사용 되지 않고 딱 한군데에서 사용되는 경우, 자식 클래스를 만드는 대신 익명 객체를 만들어서 사용
	2. 구현 클래스 대신 익명 객체 사용(제공되는 라이브러리를 이요해서 맣이 사용)
		=> 구현 클래스가 재사용 되지 않고 딱 한군데에서만 사용되는 경우, 구현 클래스를 만드는 대신 익명 객체를 만들어서 사용
	- 익명 객체는 재사용이 안될 때 사용하는 방법으로 재사용이 많이 되는 경우는 사용을 피하자. (예: 딱 한번만 사용될 때, 익명객체 사용하면 됨)
	- 익명 객체가 어려우면 굳이 사용하지 않아도 대체방법이 있다.
		=> 자식클래스를 생성하거나 구형 클래스를 생성하면 된다.
	-익명 객체를 몰라도 된다. 단, "메소드 안"에서 @Override를 본다면, 익명 객체를 이용했구나 정도만 떠올리면 된다.
		=> 메소드안에서 메소드가 구현됐는데 에러가 안난다면 익명객체를 이용한 것이다. (*일반적으로 메소드안에서 메소드를 구현하지 못함)
		

예외처리 : 예외를 처리
 	- 예외가 발생되었을 때, 예외처리가 안되어있다면 프로그램이 중단됨. 프로그램이 중단되는 걸 막기위해 예외처리를 해야한다.
	- 예외처리란? 예외를 사전에 방지하는 것이 아니라 예외가 발생했을 때, 프로그램이 중단되는 것을 막는 것을 의미
	
 	- 예외 : 코드로 해결이 가능 한 것
 	- 오류 : 코드로 해결이 불가능한 것

	-모든 예외클래스의 조상은 Exception클래스
		-일반예외 : 컴파일 과정에서 오류가 남. 실행되지 않음(코드라인옆에 빨갛게 뜨는 오류들)
		-실행예외 : 실행되는 과정에서 오류가 남. 일단 실행은 됨(콘솔창에서 빨간글자들로 에러났다고 뜨는거)
	
		
		
	실행예외의 종류
		1. NullPointerExeption  
			- 참조변수를 이용한 경우, 발생할 수 있다. =>참조변수는 null로 초기화가 가능하기 때문에
			- 객체나 배열을 생성하지 않고 멤버변수나 메소드를 사용하는 경우 발생
			해결 방법(=예외가 발생하지 않도록 사전에 처리하는 방법) //예외처리(예외가 발생했을 때, 처리하는 방법)
				1. 객체나 배열을 생성
				2. 멤버변수나 메소드를 호출하기 전에 조건문을 이용하여 null인지 체크를 하면 된다.
		 
		2. ArrayIndexOutOfBoundsException  (=배열의 번지가 범위를 벗어났다)
			- 배열을 이용할 때 발생할 수 있다.
			- 잘못된 배열 번지에 접근하는 경우, 발생한다.
			해결방법
				1. 배열의 번지는 0부터 arr.length보다 작다는 걸 기억하자. (*작거나 같다는 게 아님)
				2. 향상된 for문을 이용해도 되는 상황이면 적극적으로 이용하자.

		3. NumberFormatException
			- 문자열을 숫자로 변환할 때에 발생할 수 있다.
			- 문자열에 숫자가 아닌 문자들이 있는 경우 발생한다.
			해결방법
				1. 발생 전 처리(=해결방법)는 따로 없음ㅋㅎ, 발생 후에 처리(=예외처리)는 있음

		4. ClassCastException
			- 클래스 타입변환 시, 발생할 수 있다.
			해결방법
				1. 조건문과 instanceof 를 이용하자













	   