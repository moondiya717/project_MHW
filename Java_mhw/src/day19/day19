day19

<Review>
변수
 - 변수 선언 방법: (접근제한자) 타입 변수명; 
 - 기본 타입 종류와 값
 	- 정수형 : int, char(유니코드표에 있는 값에 따라 문자를 저장) 
 	- 실수형 : double, float 
 		*실수형은 약간의 오차가 있어서, 정확도를 높이려면 나누기보다 곱하기먼저하는게 나음. (예: A/B*C/D 보다는 A*C/(B*D)가 낫다)
 	- 논리형 : boolean 
 - 변수명 작성 규칙
 	- 숫자로 시작 불가능
 	- 예약어를 사용 불가능
 	- 특수문자는 $와 _만 사용 가능
 	- 변수 중복선언이 불가능	
 	- 대소문자를 구별함(예: int num, int Num이 다른 변수)
 - 변수명 작성 관례
	- 변수명은 소문자로 시작
	- 상수는 대문자로 한다 (final이 들어간 애들은 대문자로 예: Math.PI) 
 	- 카멜(Camel) 표기법 : 변수명이 두 단어 이상으로 되어있을 때, 두번째 단어부터 첫글자만 대문자로 표기하는 것 
 		*클래스는 첫글자를 대문자로 한다
 	- 변수명/메소드/클래스명은 의미있는 단어로 작성
 - 일반변수
 	- 기본타입으로 선언한 변수
 	- 값을 저장
 	- ==로 비교
 - 참조 변수
 	- 기본타입이 아닌 배열, 클래스, 열거형 등으로 선언한 변수
 	- 주소를 저장
 	- 비교할 때
 		1) 클래스인 경우: .equals() 메소드를 이용
 		2) 기본타입 배열은: == 
 		3) 클래스 배열: equals() 메소드 이용
 		4) 열거형은: ==이용
 - 지역변수		
 	- 사용되는 지역이 일부(메소드 하나, 반복문 한 곳 등)인 경우
 - 멤버변수
 	- 클래스의 멤버로, 사용하는 지역이 클래스 안 전체인 경우
 		*멤버변수의 종류에 따라 사용할 수 없는 메소드가 있을 수 있음
 - 매개변수
 	- 메소드를 동장시키기 위해 알려주는 정보
 	- 지역변수
 	- 멤버변수와 매개변수의 우선 순위는 매개변수가 높다.
 		* void getNum(int num){
 				this.num=num; 		//this.를 안쓰면 num=num인경우 멤버변수가아니라 매개변수로 인식
 	      }
 - 클래스 멤버 변수
 	- static이 붙은 멤버변수 
 	- 클래스를 통해 호출
 - 객체 멤버 변수
 	- static이 안붙은 멤버변수	
 	- 객체를 통해 호출(대부분 getter를 이용)	
 		
 	Quiz
 		- 하나의 변수는 변수 종류 중 한 가지에만 속한다 (X)
 	

연산자
 - 연산자 종류와 결과
 	- 산술연산자
 		- +, -, *, /, %
 		- 정수/정수 => 정수가 되어서 소수점이 사라짐(정확하지 않음)
 			*타입변환을 통해 (double)정수/정수 ="실수"가 되도록 해야 한다.
 		- % : 나머지를 확인하는 연산자
 		- 산술 연산자의 계산 결과값은 값
	- 대입연산자
		- =
		- 오른쪽에 있는 값을 왼쪽에 저장 (왼쪽에는 저장할 변수가 1개 와야 함.)
		- 저장, 덮어쓴다, 초기화 등의 표현
		- 대입연산자는 값 또는 주소값
	- 증감연산자
		- ++, --
		- 최종적으로 1증가/1감소
		- 전위형: 증가하고 동작
		- 후위형: 동작하고 증가
		- 증감연산자 결과값은 값
	- 비교연산자
		- >, <, >=, <=, ==, !=
		- 크기 비교
		- 일반변수의 크기를 비교할 때 사용
		- 비교 연산자 결과 값은 참 또는 거짓(논리 값)
		- "비교연산자 =="와 "대입연산자 ="는 다름	
	- 논리연산자
		- &&, ||, !
		- && : ~하고, A&&B에서 A,B 둘 다 참이면=> 참, 나머지는 거짓
		- || : ~거나, A||B에서 A,B 둘다 것이면 거짓 => 나머지(하나라도 참이면)는 참
  		- ! : ~아닌
  		- 논리 연산자 결과 값은 참 또는 거짓(논리값)
  	- 조건선택연산자
  		- (조건식) ? (참일때값):(거짓일때값)
  			* 조건식이 참이면 (참)에 해당하는 부분을, 거짓이면 (거짓)에 해당하는 부분을 실행
	- 조건식
		- 연산 결과가 참 또는 거짓이 되는 식
		 예) it(num=10&&num<10){		//num=10은 => num&&num<10 인 상황,문제: &&연산자는 왼쪽, 오른쪽 모두 참 거짓을 나타내는 조건식이 와야 함   
  						//실행문;				
  			}
	- 연산자 우선 순위
		- 우선순위는 ()가 제일 높다
		
		
조건문
	- ~하면 ...해라
	- ~ : 조건식, ... : 실행문
	- 조건문의 종류 (if, switch문)
	- if문
		- 모든 조건문을 다룰 수 있음
		- if문 문법
			if(조건식1){			//하나의 조건식에서 if는 한 번만
				실행문1;
			}else if(조건식2){	//0번또는 여러번
				실행문2;
			}else{
				실행문3;			//0번또는 한 번
			}
		*위의 문법에서 조건식1과 조건식2를 같이 만족하는 경우에는 실행문 1번을 실행
	- switch문
		- 사용하는 변수(식)의 값이 제한적일 때
		-switch문 문법
			switch(변수/식){
			case 값1 : 
					실행문1;
					break;	
			case 값2 : 
					실행문2;
	 				break;
	 		default : 
	 				실행문 3;
			}
		*break는 switch문을 빠져나오는 역할
		*switch문에서 break를 만나지 못하면 다음 실행문으로 이동
		
		
반복문
 - 규칙적인 작업을 여러번 할 때 사용
 - 반복횟수, 규칙성을 찾아야 한다
 - 반복문의 종류 : (for문, 향상된for문, while문, do-while문)
 - for문
 	- 문법으로 초기화, 조건식, 증감식을 입력하는 위치가 있음
 	- 초기화 : 반복문에서 사용하는 변수를 초기화, 생략가능
 	- 조건식 : 반복문 동작을 결정하는 곳으로 참이면 반복문 동작, 거짓이면 반복문 종료
			  생략가능하며 생략하면 항상 참
 	- 증감식 : 조건식에서 사용하는 변수를 증가하거나 감소시킴, 생략가능 
 	- 초기화, 조건삭, 증감식이 반복횟수를 결정
 	- for문 문법
 		for(초기화;조건식;증감식) {
 						실행문;
 		}
 - while문			
 	- 반복횟수가 정해져있지 않거나, 순차적으로 증가/감소하지 않는 경우 이용에 편리
 	- 조건식은 생략 불가능
 	- while문 문법
 		while(조건식){
 				실행문;
 		}
 - do while문
 	- 무조건 한 번은 실행
 	- ; 이 들어간다
	- doWhile문
		do{
			실행문;
		}while(조건문);
	*while의 조건문 옆에 ; 이 붙는 것이 특징

 - 향상된 for문
 	- 배열이나 리스트일 때, 향상된 for문을 사용할 수 있음
	- 배열이나 리스트의 원소들을 전체 탐색할 때 사용 (*전체 값을 확인 및 출력하는 게 포인트)
 	- 향상된 for문
 		for(타입 변수명: 배열이나 리스트){
 						실행문;
 		}
 - break
 	- switch문/반복문을 빠져나가는 역할 	
 	- 반복문에서는 if문과 함께 나옴
 - continue	
	- 스킵
	- for문에서는 증감식위치로 점프(스킵), while문에서는 조건식 위치로 스킵
	- it문과 세트로 같이 나옴
	- continue를 만나면 아래 코드가 있더라도 실행하지 않고 지정된 위치로 이동
	
<반복문 사용 시, 유의사항>
* 의도치 않은 무한루프가 생기지 않도록 주의
* 조건식을 잘못 지정해서 실행되지 않는 경우가 생기지 않도록 주의


배열	
 - (같은 의미) 같은 타입 변수들의 집합
 - 배열은 변수들을 효율적으로 관리하기 위해 사용 
 - 배열은 참조변수
 - 배열의 시작번지는 0번지부터 크기-1번지까지(예, 10개크기의배열은 0~9번지) 
 - 배열에서 번지를 잘못사용하면 ArrayIndexOutOfBounds 예외가 발생
 - 배열의 길이는 배열명.length;로 알 수 있다
 - 배열은 반복문과 같이 사용 됨
 - String의 .split("반복패턴") 으로 문자열을 그룹으로 잘라서 배열로 만들어줄 때 씀
 
 
클래스 
- 메소드
 - 하나의 기능을 하도록 모아놓은 코드
 - 메소드 선언부
 		 리턴타입 메소드명 (매개변수){ 			//메소드선언부
 											//메소드구현부
 		 }
 - 매개변수 : 메소드를 실행하기위해 필요한 정보
 - 리턴타입 : 메소드 실행 후, 알려주는 정보
 	-리턴타입 메소드
 		- 리턴값을 해당 메소드를 호출한 메소드에게 알려줌
 		- 리턴값이 없는 경우, void를 사용 
 		- 매개변수는 값 또는 주소값을 복사해서 사용
 		- 매개변수가 일반변수인 경우, 원래값(메소드를 호출한 곳에서 알려준 값)이 변경이 안됨
 		- 매개변수가 참조변수인 경우, 원래값이 변경될 수 있음 =>왱??????????????????????????
 - 메소드 오버로딩
	- 동일한 이름의 메소드가 여러개 존재할 수 있다
	- 매개변수가 다른 경우
		1) 매개변수의 갯수가 다른 경우
		2) 매개변수의 타입이 다른 경우
 - 멤버변수
 	- 클래스에서 나타낼 정보
 	- 멤버 메소드에서 멤버변수를 이용하여 동작
 	- 생성자에서 초기화 가능
 	- 멤버변수가 참조변수이면 객체를 꼭 만들어놓아야 한다 		
		- 명시적 초기화 또는 생성자 또는 초기화 블록
 - 생성자
 	- 멤버 변수들을 초기화하는 곳
 	- 일반적으로 접근제한자가 public (*싱글톤은 생성자가 private)
	- 이름이 클래스명과 동일
	- 리턴타입을 쓰지 않음
	- new를 이용하여 객체를 생성할 때 자동 호출
	- 객체 생성 후, 임의로 호출할 수 없음 (=객체만들때 빼고는 호출 불가능)
	- 생성자 오버로딩을 통해 다양한 형태의 생성자를 만들 수 있음
	- 생성자가 "없으면" 기본 생성자가 만들어짐 =>알고싶다.어떻게생기는지????????????????????????????????
 - 객체선언 및 생성	
 	-생김새
 			클래스명 객체명; 					//선언
 			클래스명 객체명 = new 클래스명(); 	//new가 객체를생성 및 초기화
 	- 객체는 생성해야 멤버 메소드와 멤버 변수를 사용할 수 있음
 	- 객체를 생성하지 않고 멤버 메소드와 멤버 변수를 사용하면, NullPointer예외가 발생 
 - 멤버 메소드를 호출하는 방법
	-생김새	
		객체명.메소드명(매개변수);
	- 접근제한자
		- public	: 본인 + 같은 패키지 + 자식 + 다른 패키지
		- protected : 본인 + 같은 패키지 + 자식
		- (default) : 본인 + 같은 패키지
		- private	: 본인 
 - static
 	- 멤버변수/메소드를 클래스멤버 변수/메소드로 만듬
 	- 클래스 변수/메소드는 모든 객체가 공유함
 	- 클래스 변수/메소드는 각 클래스에 1개만 존재
 	- static이 안붙은 멤버 변수/메소드를 객체 멤버 변수/메소드라 함
 	- 객체 변수/메소드는 각 객체마다 각각 1개씩 존재
 		(예: Math.randon() - Math클래스멤버메소드, String클래스의 메소드 중  str.indexOf() - 객체멤버메소드 //str=변수,객체명)	
  Quiz
	- 클래스 변수는 객체 메소드에서 사용할 수 있다.
	- 객체 변수는 클래스 메소드에서 바로 사용할 수 없다. 	(변환필요)
	- 클래스 메소드는 객체 메소드에서 사용할 수 있다.
	- 객체 메소드는 클래스 메소드에서 바로 사용할 수 없다. (변환필요)	
	- 클래스변수/메소드는 객체 없이 호출 가능하지만, 객체 변수/메소드는 객체가 있어야 호출이 가능하다
 - final
 	- 변할 수 없다
 	- 변수	: 상수로 바뀜
 	- 메소드	: 오버라이딩 불가
 	- 클래스	: 부모클래스가 될 수 없음 (예: String클래스는 final클래스라 부모클래스가 될 수 없다)	  		


상속
  - 부모클래스의 멤버변수/메소드를 물려 받는 것
  - extends 키워드를 이용해서 상속받음
  - 코드의 중복을 제거
  - 쉽게 클래스를 만들기 위해서
  - 서로다른 자식 클래스의 개체들을 부모 클래스가 쉽게 관리하기 위해서
  - 클래스 상속에서 부모클래스는 하나만 가능, 자식클래스는 여러개가 될 수 있음
  - 인터페이스 상속에서 부모는 여러 인터페이스가 가능 
  - 메소드 오버라이딩
  	- 부모클래스에 있는 메소드를 자식 클래스에서 재정의하는 것
  	- 부모클래스의 메소드 선언부가 동일해야한다. (매개변수, 리턴타입이 동일*)
  	- 접근제한자는 범위를 좁힐 수 없다.
  		- 부모클래스 메소드의 접근제한자가 public이면 해당 메소드를 자식 클래스에서 오버라이딩할 때 접근제한자는 public만 가능
  			* 디폴트, protected, private로 변경 불가능 =>늘릴 순 있지만, 좁힐 순 없음
  - 클래스 타입변환
 	- 클래스 타입변환은 부모와 자식관계에서만 가능
 	- 자동     : 자식클래스의 객체를 부모클래스의 객체로 변환하는 경우 => Parent p = new Child();
 	- 강제(조건): 부모클래스의 객체를 자식클래스의 객체로 변환하는 경우 => Parent p = new Child(); 
 															//부모클래스객체가 자식클래스를 통해만들어진 경우만 Child c = (Child)p; //가능 
추상클래스
 - Calendar 클래스는 대표적인 추상클래스
 - abtract를 붙여줌
 - 객체를 생성할 수 없음=> 자식클래스를 이용하여 객체를 생성
 - 추상메소드
 	- 메소드 선언부만있고 구현부가 없는 메소드
 	- 자식클래스에서 무조건 오버라이딩 해야 함. (자식클래스가 일반 클래스인 경우)
인터페이스
 - 상수와 추상메소드로 이뤄져있음
 - 실제 구현되어있는 것 없이 틀만 있는 것
 - 인터페이스를 이용하여 객체를 생성할 수 없다 
 - 인터페이스를 이용하여 구현 클래스를 만든다 => 구현클래스는 객체를 생성가능
 - implements를 이용하여 구현을 함
 - 구현클래스를 만들 때, 여러 인터페이스를 구현해도 되다,
 - 구현클래스에서는 인터페이스에이쓴 메소드들 오버라이딩해야 함   . 
 - 가능 명세서
익명객체
 - 클래스를 상속받아서 이름있는 클래스로 만드는 것이아니라 한 번 사용할 용도로 일
 - A=a = newA1
 				//멤버변수
 				//멤버메소드
 };
 예외처리
 - 프로그램이 중단되는 것 막기 위해
 - 예외 상황을 발견하고 그 상황을 해결하기 위해
 - 예외: 코드로 해결이 가능한 부분
 - 오류: 코드로 해결할 수 없는 부분
 - 일반 예외: 컴파일 단계에서 확인되어 실행되지 않는 예외
 - 실행 예외: 컴파일 단계에서 확인되지 않고, 실행 과정에서 나타나는 예외
 - 실행 예외는 예외처리를 하지 않아도 에러가 발생하지 않음.
 - 일반 예외는 예외처리를 하지 않으면 에러가 발생함.
 - 실행 예외 종류
 	- 배열과 관련된 예외 : ArrayIndexOutOfBounds
 	- 참조변수 관련 예외 : NullPointer
 	- 나누기 관련 예외	 : Arithmetic
 	- 타입변환		 : ClssCast
 	- 문자열을 숫자로	 : NumberFormat
 - 예외처리 방법
 	1) try {
 			예외가 발생할 수 있는 코드; 
 		} catch(예외클래스명1 e){
 			예외처리문1;
 		} catch(예외클래스명2 e){
 			예외처리문2;
 			return;
 		}finally{
 			실행문1
 		}
 		* 이때 예외클래스명1은 예외클래스명2의 조상클래스면 안됨.
 		* finally는 예외처리과정에서 메소드가 종료되도 무조건 실행 됨.
 		* return은 메소드가 종료됨을 이야기, finally는 return상관없이 무조건 나옴
 	2) throws
 		- 예외가 발생하면 직접처리하지 않고 예외를 던져서 남이 처리하게 하는 방법
 		- 메소드 선언부에서 매개변수 옆에 throws 예외클래스명을 입력하여 발생할 수 있는 예외를 알려줌
 		- 단, 실행예외인 경우 throws를 생략할 수 있음. (예외가 발생하더라도 던져줌)
	3) throw 예외던지기
		- 자동으로 발생되는 예외가 아닌 변수의 조건에 따라 예외를 발생시키고자 할 때 사용
		- throw는 예외 객체를 던저야하기 때문에 일반적으로 throw new 예외클래스명("예외메세지"); 형태로 던진다. 
기본 API클래스
 - Object
 	- 모든 클래스의 조상 클래스
 	- equals()
 	- toString()
 		* 모든클래스들은 Object를 상속받기때문에 이 두 개의 메소드는 다 있음.
 		* 꼭 오버라이딩을 해줘야 함. 
 - String
 	- .equals()		: 문자열이 같은지 확인
 	- .indexOf()	: 문자열이 있는지 번지알려줌
 	- .contains()	: 문자열이 있는지 있다/없다
 	- .split()		: 구분자를 기준으로 문자열을 추출하여 배열로 만듬
 	- .length()		: 문자열의 길이를 확인
 	- .replace(A,B)	: 문자열A를 B로 바꿈
 	- .toUpperCase(): 문자열을 대문자로 바꿈
 	- .toLowerCase(): 문자열을 소문자로 바꿈
 	- .trim()		: 문자열사이의 공백을 제거
 	- .subString() 	: ()를 이용해 부분값만 출력
 	- .compareTo()	: 숫자, 문자열 비교
 	- .valueOf() 	: 괄호안을 문자열로 만듬
 	
 - Math
 	- Math.abs()	: 절대값구하는 코드
	- Math.ceil()	: 소수점 올림하는 코드
	- Math.floor()	: 내림하는 코드
	- Math.rint() 	: 가까운 정수값의 "실수"
	- Math.round()	: 반올림한 정수값
	- Math.max()	: 최대값
	- Math.min() 	: 최소값
	- Math.random() : 0보다 크거나 같고 1보다 작은 임의 "실수"값을 생성하는 메소드
	- Math.pow(a,b) : a의 b제곱
	- Math.sqrt(a) 	: 루트 a
 
 - Date
 	- 날짜를 문자열로
 	- 문자열을 날짜로
 	
 - Calendar
 	- 달력
 	- 년, 월, 일, 시, 분, 초 .. 등 다양한 값들을 확인할 수 있음
 	- 추상클래스
 	
제네릭클래스
 	- 클래스의 멤버변수 또는 메소드의 타입이 객체를 선언할 때 결정되는 클래스
 	- <> 안에 클래스명이 필요. 생략하면 <Object>를 한 것과 같음
 
컬렉션 프레임워크
 - 인터페이스 : List, Set, Map
 - 데이터를 쉽게 관리하기 위해서 만들어 놓은 인터페이스	
	- List
		- 순서를 보장하며 값을 저장
		- 값이 중복될 수 있음
		- 향상된 for문을 이용할 수 있음
		- Iterator를 이용하여 값들을 가져올 수 있음(but, 꼭 사용하지 않아도 됨)
			*향상된for문, for문 등을 이용해서 값을 확인할 수 있음
		- 구현클래스
			1) ArrayList 	: 배열된 리스트
			2) LinkedList	: 연결되어있는 리스트
		- 멤버메소드 
			.add() 			: 리스트에 추가
			.get(번지)		: 번지에 있는 값을 가져옴
			.size() 		: 현재의 사이즈(지금까지 값이 얼마나 들어가있는지)를 알 수 있음 => size로 쓰고 length아님, 소괄호()있음
			.set(번지,값) 	: 번지에 값을 설정(덮어쓰기)
			.indexOf(값) 	: 값이 리스트에 있는지 없는지 확인하여 있으면 번지를 없으면-1을 반환
			.contains(값)	: 값이 리스트에 있는지 없는지 확인하여 알려주는 메소드(true,false),              equals()를 이용 
			.remove(번지) 	: 해당 번지의 값을 제거
			.remove(값)  	:  값과 일치하는 내용을 제거
			.clear() 		: 리스트를 (전체) 비움
			.isEmpty() 		: 리스트가 비어있는지 알려주는 코드 (true,false)
	- Set
		- 값이 중복 불가능, 순서보장X
		- 구현클래스
			1)HashSet
		- 멤버메소드
			 .add(객체) 		: set에 객체를 추가 => list는 add(객체), add(번지,객체)두개였는데 Set은 순서보장을 안해서 (객체) 1개밖에없음
			 .size()		: set의 크기
			 .contains(객체) : 객체가 있는지 없는지 확인   //indexOf()없음 => 번지가 없으니깐 ㅋ
			 .isEmpty()		: set이 비었는지 아닌지 확인
			 .remove()		: 객체를 삭제하고 삭제 성공 여부를 알림 => 삭제하려는 객체가 없으면 실패할 수 있음. 리턴타입 boolean (true/false)
			 .clear()		: 전체비움
		- (무조건) Iterator를 이용하여 반복문을 사용해야 값들을 가져올 수 있음
			*List에 있는 get()메소드가 없기떄문에 Iterator를 이용하지 않고는 값을 확인할 수 없음
			
	- Map
		- 두 종류의 데이터를 저장(Key와 Value)
 		- Key는 중복되지 않고, Value는 중복될 수 있음
 		- 순서를 보장하지 않음
 		- 이미 있는 key값에 중복으로 데이터를 넣으면 최신 데이터로 덮어씀(=>최근에 넣은 값이 마지막 데이터) 
 		- 값들을 확인하기 위해 Set으로 변환 시켜야 함
 			- key값들을 Set으로 만들어서 확인
 			- Entry라는 클래스를 이용하여 Set으로 만들어서 확인
 		- 멤버메소드
 			.put(key, value) 	: key와 value의 값을 저장 => key라는 이름에 value라는 값을 저장, key의 값이 중복되지 않으면 null을 리턴하고, 중복되면 이전에 저장된 value값을 리턴
 			.containsKey(객체) 	: key값에 객체와 일치하는 정보가 (boolean)있는지true 없는지false
 			.containsValue(객체) : value값에 객체와 일치하는 정보가  (boolean)있는지true 없는지false
 			.get(객체)			: key값이 객체와 일치하는 정보의 value값을 가져옴
 			출력방법1:  keySet()	: 맵의 key값들을 하나의 Set으로 만들어주는 메소드
 			Key값들을 Set으로 만든 후, Iterator사용
 			출력방법2: entrySet() : Entry클래스를 이용한 Set을 변환
 			key값과 value값을 가지는 하나의 클래스인 Entry클래스를 이용
 		- 구현
 			1)HashMap
